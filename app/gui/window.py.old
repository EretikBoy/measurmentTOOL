from PyQt6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
    QPushButton, QFileDialog, QMessageBox,
    QTableWidget, QTableWidgetItem, QHeaderView, QLabel, QLineEdit
)
from PyQt6.QtCore import Qt, QEvent
import os
import shutil
import pickle
import pandas as pd

from core.parser import DataParser
from gui.graph_dialog import GraphDialog
from core.dataprocessor import Processor

# Константы для стилей кнопок
BUTTON_STYLE_SUCCESS = '''
    background-color: rgba(76, 150, 80, 60);
'''

BUTTON_STYLE_ERROR = '''
    background-color: rgba(160, 80, 80, 60);
'''

BUTTON_STYLE_NORMAL = '''
    background-color: rgba(200, 200, 200, 60);
'''

BUTTON_STYLE_WARNING = '''
    background-color: rgba(252, 215, 3, 60);
'''

BUTTON_STYLE_ACTIVE = '''
    background-color: rgba(70, 130, 180, 60);
'''

class InstrumentWorker(QThread):
    """Рабочий поток для асинхронной работы с приборами"""
    update_signal = pyqtSignal(str)
    progress_signal = pyqtSignal(int)
    finished_signal = pyqtSignal(dict)
    error_signal = pyqtSignal(str)
    
    def __init__(self, rigol_resource, gwinstek_port, params):
        super().__init__()
        self.rigol_resource = rigol_resource
        self.gwinstek_port = gwinstek_port
        self.params = params
        self.is_running = True
        
    def run(self):
        """Основной метод потока - выполнение измерения"""
        try:
            self.update_signal.emit("Подключение к приборам...")
            
            # Подключаемся к генератору
            try:
                rigol = RigolProvider(self.rigol_resource)
                rigol.connect()
                self.update_signal.emit(f"Подключено к генератору: {rigol.model_name}")
            except Exception as e:
                self.error_signal.emit(f"Ошибка подключения к генератору: {str(e)}")
                return
                
            # Подключаемся к осциллографу
            try:
                gwinstek = GWInstekProvider(self.gwinstek_port)
                gwinstek.connect()
                self.update_signal.emit(f"Подключено к осциллографу: {gwinstek.model_name}")
            except Exception as e:
                rigol.disconnect()
                self.error_signal.emit(f"Ошибка подключения к осциллографу: {str(e)}")
                return
            
            # Настраиваем генератор
            try:
                self.update_signal.emit("Настройка генератора...")
                rigol.configure_sweep(
                    start_freq=self.params['start_freq'],
                    stop_freq=self.params['end_freq'],
                    sweep_time=self.params['record_time'],
                    function="SIN",
                    amplitude=1.0,
                    offset=0.0
                )
                self.update_signal.emit("Генератор настроен")
            except Exception as e:
                rigol.disconnect()
                gwinstek.disconnect()
                self.error_signal.emit(f"Ошибка настройки генератора: {str(e)}")
                return
            
            # Запускаем генератор
            try:
                self.update_signal.emit("Запуск генератора...")
                rigol.set_output(True)
                self.update_signal.emit("Генератор запущен")
            except Exception as e:
                rigol.disconnect()
                gwinstek.disconnect()
                self.error_signal.emit(f"Ошибка запуска генератора: {str(e)}")
                return
            
            # Ждем завершения измерения
            try:
                total_time = self.params['record_time']
                step = 0.1  # шаг обновления прогресса (секунды)
                
                for i in range(int(total_time / step)):
                    if not self.is_running:
                        break
                    
                    progress = min(100, int((i * step) / total_time * 100))
                    self.progress_signal.emit(progress)
                    self.update_signal.emit(f"Измерение... {progress}%")
                    self.msleep(int(step * 1000))  # неблокирующая задержка
                
                if self.is_running:
                    self.progress_signal.emit(100)
                    self.update_signal.emit("Измерение завершено")
            except Exception as e:
                rigol.set_output(False)
                rigol.disconnect()
                gwinstek.disconnect()
                self.error_signal.emit(f"Ошибка во время измерения: {str(e)}")
                return
            
            # Собираем данные с осциллографа
            try:
                self.update_signal.emit("Чтение данных с осциллографа...")
                channels_data = {}
                
                for ch in range(1, gwinstek.chnum + 1):
                    if not self.is_running:
                        break
                    
                    self.update_signal.emit(f"Чтение канала {ch}...")
                    channel = gwinstek.get_channel_data(ch)
                    if channel:
                        channels_data[f"CH{ch}"] = channel
                        self.update_signal.emit(f"Канал {ch} прочитан")
                
                if self.is_running:
                    self.update_signal.emit("Все данные получены")
            except Exception as e:
                rigol.set_output(False)
                rigol.disconnect()
                gwinstek.disconnect()
                self.error_signal.emit(f"Ошибка чтения данных: {str(e)}")
                return
            
            # Выключаем генератор и отключаемся
            try:
                rigol.set_output(False)
                rigol.disconnect()
                gwinstek.disconnect()
                self.update_signal.emit("Приборы отключены")
            except Exception as e:
                self.error_signal.emit(f"Ошибка при отключении приборов: {str(e)}")
                return
            
            if self.is_running:
                self.finished_signal.emit(channels_data)
                
        except Exception as e:
            self.error_signal.emit(f"Неожиданная ошибка: {str(e)}")
    
    def stop(self):
        """Остановка измерения"""
        self.is_running = False
        self.update_signal.emit("Остановка измерения...")


class MainWindow(QMainWindow):
    '''Главное окно приложения с таблицей файлов'''
    
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Анализатор каналов осциллографа')
        self.setGeometry(100, 100, 1000, 600)
        
        # Инициализация компонентов
        self.data_parser = DataParser()
        self.files_data = {}  # Словарь для хранения данных о файлах
        self.open_dialogs = {}  # Словарь для отслеживания открытых диалогов
        
        self.init_ui()
    
    def init_ui(self):
        '''Инициализация пользовательского интерфейса'''
        # Центральный виджет
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        # Основной layout
        main_layout = QVBoxLayout(central_widget)
        
        # Заголовок
        title_label = QLabel('Таблица загруженных файлов')
        title_label.setStyleSheet('font-size: 16px; font-weight: bold;')
        main_layout.addWidget(title_label)
        
        # Создаем таблицу
        self.table = QTableWidget()
        self.table.setColumnCount(7)
        self.table.setHorizontalHeaderLabels([
            'Код предмета', 
            'Файл', 
            'Графики и \nподстройка значений', 
            'Параметр 1', 
            'Параметр 2', 
            'Параметр 3',
            'Параметр 4'
        ])
        
        # Настраиваем внешний вид таблицы
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.table.verticalHeader().setVisible(False)
        
        # Кнопка добавления строки
        add_row_button = QPushButton('Добавить предмет')
        add_row_button.clicked.connect(self.add_table_row)
        
        # Кнопка загрузки файла
        self.load_button = QPushButton('Загрузить файл')
        self.load_button.clicked.connect(self.load_file)
        
        # Кнопка добавления нескольких файлов
        self.load_multiple_button = QPushButton('Загрузить несколько файлов')
        self.load_multiple_button.clicked.connect(self.load_multiple_files)
        
        # Кнопка удаления строки
        self.delete_button = QPushButton('Удалить выбранные строки (Del)')
        self.delete_button.clicked.connect(self.delete_selected_rows)
        
        # Кнопка сохранения анализа
        self.save_analysis_button = QPushButton('Сохранить анализ')
        self.save_analysis_button.clicked.connect(self.save_analysis)
        
        # Кнопка загрузки анализа
        self.load_analysis_button = QPushButton('Загрузить анализ')
        self.load_analysis_button.clicked.connect(self.load_analysis)
        
        # Панель кнопок
        button_layout = QHBoxLayout()
        button_layout.addWidget(add_row_button)
        button_layout.addWidget(self.load_button)
        button_layout.addWidget(self.load_multiple_button)
        button_layout.addWidget(self.delete_button)
        button_layout.addWidget(self.save_analysis_button)
        button_layout.addWidget(self.load_analysis_button)
        
        # Добавляем элементы в основной layout
        main_layout.addLayout(button_layout)
        main_layout.addWidget(self.table)
        
        # Устанавливаем обработчик клавиш
        self.installEventFilter(self)
    
    def eventFilter(self, obj, event):
        '''Обработка нажатий клавиш'''
        if event.type() == QEvent.Type.KeyPress and event.key() == Qt.Key.Key_Delete:
            self.delete_selected_rows()
            return True
        return super().eventFilter(obj, event)
    
    def set_button_style(self, button, style_type='normal'):
        '''Установка стиля для кнопки'''
        if style_type == 'success':
            button.setStyleSheet(BUTTON_STYLE_SUCCESS)
        elif style_type == 'error':
            button.setStyleSheet(BUTTON_STYLE_ERROR)
        elif style_type == 'warning':
            button.setStyleSheet(BUTTON_STYLE_WARNING)
        else:
            button.setStyleSheet(BUTTON_STYLE_NORMAL)
    
    def add_table_row(self):
        '''Добавление новой строки в таблицу'''
        row_position = self.table.rowCount()
        self.table.insertRow(row_position)
        
        # Поле для кода предмета
        subject_item = QTableWidgetItem('')
        self.table.setItem(row_position, 0, subject_item)
        
        # Кнопка добавления файла для этой строки
        file_button = QPushButton('Добавить файл')
        file_button.clicked.connect(lambda: self.load_file_for_row(row_position))
        self.set_button_style(file_button, 'normal')
        self.table.setCellWidget(row_position, 1, file_button)
        
        # Кнопка для открытия графика (изначально неактивна)
        graph_button = QPushButton('Открыть графики')
        graph_button.setEnabled(False)
        graph_button.clicked.connect(lambda: self.open_graph_dialog(row_position))
        self.table.setCellWidget(row_position, 2, graph_button)
        
        # Параметры (нули)
        for col in range(3, 7):
            param_item = QTableWidgetItem('0')
            self.table.setItem(row_position, col, param_item)
    
    def load_multiple_files(self):
        '''Загрузка нескольких файлов одновременно'''
        file_paths, _ = QFileDialog.getOpenFileNames(
            self, 
            'Выберите файлы данных', 
            '', 
            'Excel Files (*.xlsx *.xls *.csv);;All Files (*)'
        )
        
        if not file_paths:
            return
        
        # Добавляем строки для всех файлов
        for file_path in file_paths:
            row_position = self.table.rowCount()
            self.add_table_row()
            self.load_file_to_row(file_path, row_position)
    
    def load_file_to_row(self, file_path, row_position):
        '''Загрузка файла в конкретную строку'''
        try:
            # Парсим файл
            file_format = file_path.split('.')[-1]
            success = self.data_parser.parsefile(file_path, file_format)
            
            if not success:
                QMessageBox.warning(self, 'Ошибка', f'Не удалось загрузить файл: {file_path}')
                # Обновляем кнопку в случае ошибки
                file_button = self.table.cellWidget(row_position, 1)
                file_button.setText('Ошибка загрузки')
                self.set_button_style(file_button, 'error')
                return
            
            # Получаем имя файла без пути
            file_name = file_path.split('/')[-1]
            
            # Обновляем кнопку загрузки файла
            file_button = self.table.cellWidget(row_position, 1)
            file_button.setText(file_name)
            self.set_button_style(file_button, 'success')
            
            # Активируем кнопку открытия графиков
            graph_button = self.table.cellWidget(row_position, 2)
            graph_button.setEnabled(True)
            graph_button.setText('Открыть графики')
            
            # Парсим параметры из имени файла
            file_name_without_ext = file_name.split('.')[0]
            name_parts = file_name_without_ext.split('_')
            
            # Значения по умолчанию
            start_freq = 1
            bandwidth = 1
            record_time = 1
            identifier = f'AN{row_position}'
            
            if len(name_parts) >= 4:
                try:
                    # Извлекаем параметры из имени файла
                    identifier = str(name_parts[0])
                    start_freq = int(name_parts[1])
                    bandwidth = int(name_parts[2])
                    record_time = int(name_parts[3])
                except ValueError:
                    QMessageBox.warning(self, 'Предупреждение', 
                                       f'Не удалось извлечь параметры из имени файла {file_name}, данные записаны неверно')
                    # Обновляем кнопку в случае ошибки
                    file_button = self.table.cellWidget(row_position, 1)
                    file_button.setText(f'Установите параметры\nвручную: {file_name}')
                    self.set_button_style(file_button, 'warning')
            else:
                QMessageBox.warning(self, 'Предупреждение', 
                                       f'Не удалось извлечь параметры из имени файла {file_name}, данные записаны неверно')
                # Обновляем кнопку в случае ошибки
                file_button = self.table.cellWidget(row_position, 1)
                file_button.setText(f'Установите параметры\nвручную: {file_name}')
                self.set_button_style(file_button, 'warning')
            
            end_freq = start_freq + bandwidth
            
            # Сохраняем данные файла
            self.files_data[row_position] = {
                'path': file_path,
                'file_name': file_name,  # Сохраняем имя файла
                'channels': {},
                'params': {
                    'start_freq': start_freq,
                    'end_freq': end_freq,
                    'record_time': record_time,
                    'cut_second': 0,
                    'fixedlevel': 0.6,
                    'gain': 7
                }
            }
            
            # Получаем каналы
            for channel_name in self.data_parser.get_channel_names():
                channel = self.data_parser.get_channel(channel_name)
                if channel and not channel.data.empty:
                    self.files_data[row_position]['channels'][channel_name] = channel
            
            # Создаём процессор для файла
            self.files_data[row_position]['processor'] = Processor(self.files_data[row_position])

            # Обновляем параметры в таблице
            self.table.item(row_position, 0).setText(str(identifier))
            self.table.item(row_position, 3).setText(str(self.files_data[row_position]['processor'].start_freq))
            self.table.item(row_position, 4).setText(str(self.files_data[row_position]['processor'].end_freq))
            self.table.item(row_position, 5).setText(str(self.files_data[row_position]['processor'].record_time))
            self.table.item(row_position, 6).setText(str(self.files_data[row_position]['processor'].cut_second))
                
        except Exception as e:
            QMessageBox.critical(self, 'Ошибка', f'Произошла ошибка при загрузке файла: {str(e)}')
            
            # Обновляем кнопку в случае ошибки
            file_button = self.table.cellWidget(row_position, 1)
            file_button.setText('Ошибка загрузки')
            self.set_button_style(file_button, 'error')
    
    def load_file_for_row(self, row):
        '''Загрузка файла для конкретной строки'''
        file_path, _ = QFileDialog.getOpenFileName(
            self, 
            'Выберите файл данных', 
            '', 
            'Excel Files (*.xlsx *.xls *.csv);;All Files (*)'
        )
        
        if not file_path:
            return
            
        self.load_file_to_row(file_path, row)
    
    def delete_selected_rows(self):
        '''Удаление выбранных строк и связанных с ними данных'''
        selected_rows = set()
        for item in self.table.selectedItems():
            selected_rows.add(item.row())
        
        if not selected_rows:
            QMessageBox.information(self, 'Информация', 'Пожалуйста, выберите строки для удаления')
            return
        
        # Сортируем строки в обратном порядке для правильного удаления
        sorted_rows = sorted(selected_rows, reverse=True)
        
        for row in sorted_rows:
            # Удаляем данные файла из словаря
            if row in self.files_data:
                del self.files_data[row]
            
            # Закрываем связанные диалоги, если они открыты
            if row in self.open_dialogs:
                self.open_dialogs[row].close()
                del self.open_dialogs[row]
            
            # Удаляем строку из таблицы
            self.table.removeRow(row)
            
            # Обновляем индексы оставшихся файлов
            new_files_data = {}
            new_open_dialogs = {}
            for existing_row, data in self.files_data.items():
                if existing_row > row:
                    new_files_data[existing_row-1] = data
                    if existing_row in self.open_dialogs:
                        new_open_dialogs[existing_row-1] = self.open_dialogs[existing_row]
                elif existing_row < row:
                    new_files_data[existing_row] = data
                    if existing_row in self.open_dialogs:
                        new_open_dialogs[existing_row] = self.open_dialogs[existing_row]
            self.files_data = new_files_data
            self.open_dialogs = new_open_dialogs
        
        # Обновляем связи кнопок с новыми номерами строк
        for row in range(self.table.rowCount()):
            # Обновляем кнопку загрузки файла
            file_button = self.table.cellWidget(row, 1)
            file_button.clicked.disconnect()
            file_button.clicked.connect(lambda checked, r=row: self.load_file_for_row(r))
            
            # Обновляем кнопку открытия графиков
            graph_button = self.table.cellWidget(row, 2)
            if graph_button.isEnabled():
                graph_button.clicked.disconnect()
                graph_button.clicked.connect(lambda checked, r=row: self.open_graph_dialog(r))
    
    def open_graph_dialog(self, row):
        '''Открытие диалога с графиками и настройками'''
        if row not in self.files_data:
            QMessageBox.warning(self, 'Ошибка', 'Данные файла не найдены')
            return
        
        # Если диалог для этой строки уже открыт, активируем его
        if row in self.open_dialogs:
            self.open_dialogs[row].raise_()
            self.open_dialogs[row].activateWindow()
            return
        
        # Получаем данные для выбранной строки
        file_data = self.files_data[row]
        file_name = file_data['file_name']
        
        # Создаем и показываем диалог
        dialog = GraphDialog(file_data['channels'], file_data['params'], file_data['processor'], file_name, self)
        
        # Сохраняем ссылку на диалог
        self.open_dialogs[row] = dialog
        
        # Подключаем сигнал закрытия диалога
        dialog.finished.connect(lambda: self.on_graph_dialog_closed(row))
        
        # Показываем диалог
        dialog.show()
    
    def on_graph_dialog_closed(self, row):
        '''Обработчик закрытия диалога с графиками'''
        if row in self.open_dialogs:
            # Получаем диалог
            dialog = self.open_dialogs[row]
            
            # Обновляем параметры после закрытия диалога
            if row in self.files_data:
                self.files_data[row]['params'] = dialog.params
                
                # Обновляем таблицу
                self.table.item(row, 3).setText(str(dialog.params['start_freq']))
                self.table.item(row, 4).setText(str(dialog.params['end_freq']))
                self.table.item(row, 5).setText(str(dialog.params['record_time']))
                self.table.item(row, 6).setText(str(dialog.params['cut_second']))
            
            # Удаляем диалог из словаря открытых диалогов
            del self.open_dialogs[row]
    
    def load_file(self):
        '''Загрузка файла (альтернативный метод)'''
        # Просто добавляем новую строки и загружаем в нее файл
        self.add_table_row()
        self.load_file_for_row(self.table.rowCount() - 1)

    def save_analysis(self):
        '''Сохранение анализа в папку tables'''
        if not self.files_data:
            QMessageBox.warning(self, 'Предупреждение', 'Нет данных для сохранения')
            return
        
        # Создаем папку tables если ее нет
        if not os.path.exists('tables'):
            os.makedirs('tables')
        
        # Запрашиваем имя файла для сохранения
        file_name, _ = QFileDialog.getSaveFileName(
            self, 
            'Сохранить анализ', 
            'tables/analysis.analysis', 
            'Analysis Files (*.analysis)'
        )
        
        if not file_name:
            return
        
        # Создаем папку с тем же именем что и файл
        base_name = os.path.splitext(os.path.basename(file_name))[0]
        folder_name = os.path.join(os.path.dirname(file_name), base_name)
        
        if not os.path.exists(folder_name):
            os.makedirs(folder_name)
        
        try:
            # Подготавливаем данные для сохранения
            analysis_data = {
                'rows': [],
                'files': {}
            }
            
            # Копируем файлы и сохраняем информацию
            for row, data in self.files_data.items():
                # Копируем файл в папку
                try:
                    src_file = data['path']
                    dst_file = os.path.join(folder_name, data['file_name'])
                    shutil.copy2(src_file, dst_file)
                except Exception as e:
                    QMessageBox.critical(self, 'Ошибка', f'Строки таблицы не имеют привязки, данные сохраняться без исходных файлов')
                
                # Сохраняем информацию о строке
                row_data = {
                    'subject_code': self.table.item(row, 0).text(),
                    'file_name': data['file_name'],
                    'params': data['params'],
                    'processor': data['processor'],
                    # Сохраняем данные каналов
                    'channels_data': {}
                }
                
                # Сохраняем данные каждого канала
                for channel_name, channel in data['channels'].items():
                    row_data['channels_data'][channel_name] = {
                        'data': channel.data.to_dict(),
                        'name': channel.name
                    }
                
                analysis_data['rows'].append((row, row_data))
                analysis_data['files'][row] = data['file_name']
            
            # Сохраняем данные анализа
            with open(file_name, 'wb') as f:
                pickle.dump(analysis_data, f)
            
            QMessageBox.information(self, 'Успех', 'Анализ успешно сохранен')
            
        except Exception as e:
            QMessageBox.critical(self, 'Ошибка', f'Ошибка при сохранении анализа: {str(e)}')
    
    def load_analysis(self):
        '''Загрузка анализа из файла'''
        file_name, _ = QFileDialog.getOpenFileName(
            self, 
            'Загрузить анализ', 
            'tables', 
            'Analysis Files (*.analysis)'
        )
        
        if not file_name:
            return
        
        # Определяем папку с файлами
        base_name = os.path.splitext(os.path.basename(file_name))[0]
        folder_name = os.path.join(os.path.dirname(file_name), base_name)
        
        if not os.path.exists(file_name) or not os.path.exists(folder_name):
            QMessageBox.critical(self, 'Ошибка', 'Файл анализа или папка с данными не найдены')
            pass
        
        try:
            # Загружаем данные анализа
            with open(file_name, 'rb') as f:
                analysis_data = pickle.load(f)
            
            # Очищаем текущие данные
            self.table.setRowCount(0)
            self.files_data = {}
            for dialog in self.open_dialogs.values():
                dialog.close()
            self.open_dialogs = {}
            
            # Восстанавливаем строки
            for row, row_data in analysis_data['rows']:
                self.add_table_row()
                
                # Проверяем доступность файла
                file_path = os.path.join(folder_name, row_data['file_name'])
                file_exists = os.path.exists(file_path)
                
                # Восстанавливаем данные
                self.table.item(row, 0).setText(row_data['subject_code'])
                
                file_button = self.table.cellWidget(row, 1)
                if not file_exists:
                    file_button.setText(f'Файл недоступен:\n{row_data["file_name"]}')
                    self.set_button_style(file_button, 'error')
                else:
                    file_button.setText(row_data['file_name'])
                    self.set_button_style(file_button, 'success')
                
                graph_button = self.table.cellWidget(row, 2)
                graph_button.setEnabled(True)
                graph_button.setText('Открыть графики')
                
                # Восстанавливаем параметры
                self.table.item(row, 3).setText(str(row_data['params']['start_freq']))
                self.table.item(row, 4).setText(str(row_data['params']['end_freq']))
                self.table.item(row, 5).setText(str(row_data['params']['record_time']))
                self.table.item(row, 6).setText(str(row_data['params']['cut_second']))
                
                # Восстанавливаем каналы
                channels = {}
                for channel_name, channel_data in row_data['channels_data'].items():
                    # Создаем объект канала и восстанавливаем данные
                    channel = type('Channel', (), {})()
                    channel.name = channel_data['name']
                    channel.data = pd.DataFrame(channel_data['data'])
                    channels[channel_name] = channel
                
                # Восстанавливаем files_data
                self.files_data[row] = {
                    'path': file_path if file_exists else None,
                    'file_name': row_data['file_name'],
                    'params': row_data['params'],
                    'processor': row_data['processor'],
                    'channels': channels
                }
            
            QMessageBox.information(self, 'Успех', 'Анализ успешно загружен')
            
        except Exception as e:
            QMessageBox.critical(self, 'Ошибка', f'Ошибка при загрузке анализа: {str(e)}')